/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.19.2.
 * Original file: /npm/@microsoft/signalr@8.0.0/dist/esm/index.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
class e extends Error { constructor(e, t) { const n = new.target.prototype; super(`${e}: Status code '${t}'`), this.statusCode = t, this.__proto__ = n } } class t extends Error { constructor(e = "A timeout occurred.") { const t = new.target.prototype; super(e), this.__proto__ = t } } class n extends Error { constructor(e = "An abort occurred.") { const t = new.target.prototype; super(e), this.__proto__ = t } } class o extends Error { constructor(e, t) { const n = new.target.prototype; super(e), this.transport = t, this.errorType = "UnsupportedTransportError", this.__proto__ = n } } class r extends Error { constructor(e, t) { const n = new.target.prototype; super(e), this.transport = t, this.errorType = "DisabledTransportError", this.__proto__ = n } } class s extends Error { constructor(e, t) { const n = new.target.prototype; super(e), this.transport = t, this.errorType = "FailedToStartTransportError", this.__proto__ = n } } class i extends Error { constructor(e) { const t = new.target.prototype; super(e), this.errorType = "FailedToNegotiateWithServerError", this.__proto__ = t } } class c extends Error { constructor(e, t) { const n = new.target.prototype; super(e), this.innerErrors = t, this.__proto__ = n } } class a { constructor(e, t, n) { this.statusCode = e, this.statusText = t, this.content = n } } class l { get(e, t) { return this.send({ ...t, method: "GET", url: e }) } post(e, t) { return this.send({ ...t, method: "POST", url: e }) } delete(e, t) { return this.send({ ...t, method: "DELETE", url: e }) } getCookieString(e) { return "" } } var h; !function (e) { e[e.Trace = 0] = "Trace", e[e.Debug = 1] = "Debug", e[e.Information = 2] = "Information", e[e.Warning = 3] = "Warning", e[e.Error = 4] = "Error", e[e.Critical = 5] = "Critical", e[e.None = 6] = "None" }(h || (h = {})); var u = "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}; function g() { throw new Error("setTimeout has not been defined") } function d() { throw new Error("clearTimeout has not been defined") } var _ = g, p = d; function f(e) { if (_ === setTimeout) return setTimeout(e, 0); if ((_ === g || !_) && setTimeout) return _ = setTimeout, setTimeout(e, 0); try { return _(e, 0) } catch (t) { try { return _.call(null, e, 0) } catch (t) { return _.call(this, e, 0) } } } "function" == typeof u.setTimeout && (_ = setTimeout), "function" == typeof u.clearTimeout && (p = clearTimeout); var m, w = [], v = !1, b = -1; function y() { v && m && (v = !1, m.length ? w = m.concat(w) : b = -1, w.length && S()) } function S() { if (!v) { var e = f(y); v = !0; for (var t = w.length; t;) { for (m = w, w = []; ++b < t;)m && m[b].run(); b = -1, t = w.length } m = null, v = !1, function (e) { if (p === clearTimeout) return clearTimeout(e); if ((p === d || !p) && clearTimeout) return p = clearTimeout, clearTimeout(e); try { return p(e) } catch (t) { try { return p.call(null, e) } catch (t) { return p.call(this, e) } } }(e) } } function C(e, t) { this.fun = e, this.array = t } C.prototype.run = function () { this.fun.apply(null, this.array) }; function k() { } var T = k, E = k, I = k, P = k, $ = k, R = k, D = k; var M = u.performance || {}, q = M.now || M.mozNow || M.msNow || M.oNow || M.webkitNow || function () { return (new Date).getTime() }; var x = new Date; var H = { nextTick: function (e) { var t = new Array(arguments.length - 1); if (arguments.length > 1) for (var n = 1; n < arguments.length; n++)t[n - 1] = arguments[n]; w.push(new C(e, t)), 1 !== w.length || v || f(S) }, title: "browser", browser: !0, env: {}, argv: [], version: "", versions: {}, on: T, addListener: E, once: I, off: P, removeListener: $, removeAllListeners: R, emit: D, binding: function (e) { throw new Error("process.binding is not supported") }, cwd: function () { return "/" }, chdir: function (e) { throw new Error("process.chdir is not supported") }, umask: function () { return 0 }, hrtime: function (e) { var t = .001 * q.call(M), n = Math.floor(t), o = Math.floor(t % 1 * 1e9); return e && (n -= e[0], (o -= e[1]) < 0 && (n--, o += 1e9)), [n, o] }, platform: "browser", release: {}, config: {}, uptime: function () { return (new Date - x) / 1e3 } }; class N { constructor() { } log(e, t) { } } N.instance = new N; const A = "8.0.0"; class W { static isRequired(e, t) { if (null == e) throw new Error(`The '${t}' argument is required.`) } static isNotEmpty(e, t) { if (!e || e.match(/^\s*$/)) throw new Error(`The '${t}' argument should not be empty.`) } static isIn(e, t, n) { if (!(e in t)) throw new Error(`Unknown ${n} value: ${e}.`) } } class L { static get isBrowser() { return !L.isNode && "object" == typeof window && "object" == typeof window.document } static get isWebWorker() { return !L.isNode && "object" == typeof self && "importScripts" in self } static get isReactNative() { return !L.isNode && "object" == typeof window && void 0 === window.document } static get isNode() { return void 0 !== H && H.release && "node" === H.release.name } } function j(e, t) { let n = ""; return B(e) ? (n = `Binary data of length ${e.byteLength}`, t && (n += `. Content: '${function (e) { const t = new Uint8Array(e); let n = ""; return t.forEach((e => { n += `0x${e < 16 ? "0" : ""}${e.toString(16)} ` })), n.substr(0, n.length - 1) }(e)}'`)) : "string" == typeof e && (n = `String data of length ${e.length}`, t && (n += `. Content: '${e}'`)), n } function B(e) { return e && "undefined" != typeof ArrayBuffer && (e instanceof ArrayBuffer || e.constructor && "ArrayBuffer" === e.constructor.name) } async function F(e, t, n, o, r, s) { const i = {}, [c, a] = z(); i[c] = a, e.log(h.Trace, `(${t} transport) sending data. ${j(r, s.logMessageContent)}.`); const l = B(r) ? "arraybuffer" : "text", u = await n.post(o, { content: r, headers: { ...i, ...s.headers }, responseType: l, timeout: s.timeout, withCredentials: s.withCredentials }); e.log(h.Trace, `(${t} transport) request complete. Response status: ${u.statusCode}.`) } class U { constructor(e, t) { this._subject = e, this._observer = t } dispose() { const e = this._subject.observers.indexOf(this._observer); e > -1 && this._subject.observers.splice(e, 1), 0 === this._subject.observers.length && this._subject.cancelCallback && this._subject.cancelCallback().catch((e => { })) } } class O { constructor(e) { this._minLevel = e, this.out = console } log(e, t) { if (e >= this._minLevel) { const n = `[${(new Date).toISOString()}] ${h[e]}: ${t}`; switch (e) { case h.Critical: case h.Error: this.out.error(n); break; case h.Warning: this.out.warn(n); break; case h.Information: this.out.info(n); break; default: this.out.log(n) } } } } function z() { let e = "X-SignalR-User-Agent"; return L.isNode && (e = "User-Agent"), [e, K(A, X(), V(), J())] } function K(e, t, n, o) { let r = "Microsoft SignalR/"; const s = e.split("."); return r += `${s[0]}.${s[1]}`, r += ` (${e}; `, r += t && "" !== t ? `${t}; ` : "Unknown OS; ", r += `${n}`, r += o ? `; ${o}` : "; Unknown Runtime Version", r += ")", r } function X() { if (!L.isNode) return ""; switch (H.platform) { case "win32": return "Windows NT"; case "darwin": return "macOS"; case "linux": return "Linux"; default: return H.platform } } function J() { if (L.isNode) return H.versions.node } function V() { return L.isNode ? "NodeJS" : "Browser" } function Q(e) { return e.stack ? e.stack : e.message ? e.message : `${e}` } class G extends l { constructor(e) { super(), this._logger = e; const t = { _fetchType: void 0, _jar: void 0 }; var n; n = t, ("undefined" == typeof fetch || L.isNode) && (n._jar = new (require("tough-cookie").CookieJar), "undefined" == typeof fetch ? n._fetchType = require("node-fetch") : n._fetchType = fetch, n._fetchType = require("fetch-cookie")(n._fetchType, n._jar), 1) ? (this._fetchType = t._fetchType, this._jar = t._jar) : this._fetchType = fetch.bind(function () { if ("undefined" != typeof globalThis) return globalThis; if ("undefined" != typeof self) return self; if ("undefined" != typeof window) return window; if (void 0 !== u) return u; throw new Error("could not find global") }()), this._abortControllerType = AbortController; const o = { _abortControllerType: this._abortControllerType }; (function (e) { return "undefined" == typeof AbortController && (e._abortControllerType = require("abort-controller"), !0) })(o) && (this._abortControllerType = o._abortControllerType) } async send(o) { if (o.abortSignal && o.abortSignal.aborted) throw new n; if (!o.method) throw new Error("No method defined."); if (!o.url) throw new Error("No url defined."); const r = new this._abortControllerType; let s; o.abortSignal && (o.abortSignal.onabort = () => { r.abort(), s = new n }); let i, c = null; if (o.timeout) { const e = o.timeout; c = setTimeout((() => { r.abort(), this._logger.log(h.Warning, "Timeout from HTTP request."), s = new t }), e) } "" === o.content && (o.content = void 0), o.content && (o.headers = o.headers || {}, B(o.content) ? o.headers["Content-Type"] = "application/octet-stream" : o.headers["Content-Type"] = "text/plain;charset=UTF-8"); try { i = await this._fetchType(o.url, { body: o.content, cache: "no-cache", credentials: !0 === o.withCredentials ? "include" : "same-origin", headers: { "X-Requested-With": "XMLHttpRequest", ...o.headers }, method: o.method, mode: "cors", redirect: "follow", signal: r.signal }) } catch (e) { if (s) throw s; throw this._logger.log(h.Warning, `Error from HTTP request. ${e}.`), e } finally { c && clearTimeout(c), o.abortSignal && (o.abortSignal.onabort = null) } if (!i.ok) { const t = await Y(i, "text"); throw new e(t || i.statusText, i.status) } const l = Y(i, o.responseType), u = await l; return new a(i.status, i.statusText, u) } getCookieString(e) { let t = ""; return L.isNode && this._jar && this._jar.getCookies(e, ((e, n) => t = n.join("; "))), t } } function Y(e, t) { let n; switch (t) { case "arraybuffer": n = e.arrayBuffer(); break; case "text": default: n = e.text(); break; case "blob": case "document": case "json": throw new Error(`${t} is not supported.`) }return n } class Z extends l { constructor(e) { super(), this._logger = e } send(o) { return o.abortSignal && o.abortSignal.aborted ? Promise.reject(new n) : o.method ? o.url ? new Promise(((r, s) => { const i = new XMLHttpRequest; i.open(o.method, o.url, !0), i.withCredentials = void 0 === o.withCredentials || o.withCredentials, i.setRequestHeader("X-Requested-With", "XMLHttpRequest"), "" === o.content && (o.content = void 0), o.content && (B(o.content) ? i.setRequestHeader("Content-Type", "application/octet-stream") : i.setRequestHeader("Content-Type", "text/plain;charset=UTF-8")); const c = o.headers; c && Object.keys(c).forEach((e => { i.setRequestHeader(e, c[e]) })), o.responseType && (i.responseType = o.responseType), o.abortSignal && (o.abortSignal.onabort = () => { i.abort(), s(new n) }), o.timeout && (i.timeout = o.timeout), i.onload = () => { o.abortSignal && (o.abortSignal.onabort = null), i.status >= 200 && i.status < 300 ? r(new a(i.status, i.statusText, i.response || i.responseText)) : s(new e(i.response || i.responseText || i.statusText, i.status)) }, i.onerror = () => { this._logger.log(h.Warning, `Error from HTTP request. ${i.status}: ${i.statusText}.`), s(new e(i.statusText, i.status)) }, i.ontimeout = () => { this._logger.log(h.Warning, "Timeout from HTTP request."), s(new t) }, i.send(o.content) })) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined.")) } } class ee extends l { constructor(e) { if (super(), "undefined" != typeof fetch || L.isNode) this._httpClient = new G(e); else { if ("undefined" == typeof XMLHttpRequest) throw new Error("No usable HttpClient found."); this._httpClient = new Z(e) } } send(e) { return e.abortSignal && e.abortSignal.aborted ? Promise.reject(new n) : e.method ? e.url ? this._httpClient.send(e) : Promise.reject(new Error("No url defined.")) : Promise.reject(new Error("No method defined.")) } getCookieString(e) { return this._httpClient.getCookieString(e) } } class te { static write(e) { return `${e}${te.RecordSeparator}` } static parse(e) { if (e[e.length - 1] !== te.RecordSeparator) throw new Error("Message is incomplete."); const t = e.split(te.RecordSeparator); return t.pop(), t } } te.RecordSeparatorCode = 30, te.RecordSeparator = String.fromCharCode(te.RecordSeparatorCode); class ne { writeHandshakeRequest(e) { return te.write(JSON.stringify(e)) } parseHandshakeResponse(e) { let t, n; if (B(e)) { const o = new Uint8Array(e), r = o.indexOf(te.RecordSeparatorCode); if (-1 === r) throw new Error("Message is incomplete."); const s = r + 1; t = String.fromCharCode.apply(null, Array.prototype.slice.call(o.slice(0, s))), n = o.byteLength > s ? o.slice(s).buffer : null } else { const o = e, r = o.indexOf(te.RecordSeparator); if (-1 === r) throw new Error("Message is incomplete."); const s = r + 1; t = o.substring(0, s), n = o.length > s ? o.substring(s) : null } const o = te.parse(t), r = JSON.parse(o[0]); if (r.type) throw new Error("Expected a handshake response from the server."); return [n, r] } } var oe; !function (e) { e[e.Invocation = 1] = "Invocation", e[e.StreamItem = 2] = "StreamItem", e[e.Completion = 3] = "Completion", e[e.StreamInvocation = 4] = "StreamInvocation", e[e.CancelInvocation = 5] = "CancelInvocation", e[e.Ping = 6] = "Ping", e[e.Close = 7] = "Close", e[e.Ack = 8] = "Ack", e[e.Sequence = 9] = "Sequence" }(oe || (oe = {})); class re { constructor() { this.observers = [] } next(e) { for (const t of this.observers) t.next(e) } error(e) { for (const t of this.observers) t.error && t.error(e) } complete() { for (const e of this.observers) e.complete && e.complete() } subscribe(e) { return this.observers.push(e), new U(this, e) } } class se { constructor(e, t, n) { this._bufferSize = 1e5, this._messages = [], this._totalMessageCount = 0, this._waitForSequenceMessage = !1, this._nextReceivingSequenceId = 1, this._latestReceivedSequenceId = 0, this._bufferedByteCount = 0, this._reconnectInProgress = !1, this._protocol = e, this._connection = t, this._bufferSize = n } async _send(e) { const t = this._protocol.writeMessage(e); let n = Promise.resolve(); if (this._isInvocationMessage(e)) { this._totalMessageCount++; let e = () => { }, o = () => { }; B(t) ? this._bufferedByteCount += t.byteLength : this._bufferedByteCount += t.length, this._bufferedByteCount >= this._bufferSize && (n = new Promise(((t, n) => { e = t, o = n }))), this._messages.push(new ie(t, this._totalMessageCount, e, o)) } try { this._reconnectInProgress || await this._connection.send(t) } catch { this._disconnected() } await n } _ack(e) { let t = -1; for (let n = 0; n < this._messages.length; n++) { const o = this._messages[n]; if (o._id <= e.sequenceId) t = n, B(o._message) ? this._bufferedByteCount -= o._message.byteLength : this._bufferedByteCount -= o._message.length, o._resolver(); else { if (!(this._bufferedByteCount < this._bufferSize)) break; o._resolver() } } -1 !== t && (this._messages = this._messages.slice(t + 1)) } _shouldProcessMessage(e) { if (this._waitForSequenceMessage) return e.type === oe.Sequence && (this._waitForSequenceMessage = !1, !0); if (!this._isInvocationMessage(e)) return !0; const t = this._nextReceivingSequenceId; return this._nextReceivingSequenceId++, t <= this._latestReceivedSequenceId ? (t === this._latestReceivedSequenceId && this._ackTimer(), !1) : (this._latestReceivedSequenceId = t, this._ackTimer(), !0) } _resetSequence(e) { e.sequenceId > this._nextReceivingSequenceId ? this._connection.stop(new Error("Sequence ID greater than amount of messages we've received.")) : this._nextReceivingSequenceId = e.sequenceId } _disconnected() { this._reconnectInProgress = !0, this._waitForSequenceMessage = !0 } async _resend() { const e = 0 !== this._messages.length ? this._messages[0]._id : this._totalMessageCount + 1; await this._connection.send(this._protocol.writeMessage({ type: oe.Sequence, sequenceId: e })); const t = this._messages; for (const e of t) await this._connection.send(e._message); this._reconnectInProgress = !1 } _dispose(e) { null != e || (e = new Error("Unable to reconnect to server.")); for (const t of this._messages) t._rejector(e) } _isInvocationMessage(e) { switch (e.type) { case oe.Invocation: case oe.StreamItem: case oe.Completion: case oe.StreamInvocation: case oe.CancelInvocation: return !0; case oe.Close: case oe.Sequence: case oe.Ping: case oe.Ack: return !1 } } _ackTimer() { void 0 === this._ackTimerHandle && (this._ackTimerHandle = setTimeout((async () => { try { this._reconnectInProgress || await this._connection.send(this._protocol.writeMessage({ type: oe.Ack, sequenceId: this._latestReceivedSequenceId })) } catch { } clearTimeout(this._ackTimerHandle), this._ackTimerHandle = void 0 }), 1e3)) } } class ie { constructor(e, t, n, o) { this._message = e, this._id = t, this._resolver = n, this._rejector = o } } var ce; !function (e) { e.Disconnected = "Disconnected", e.Connecting = "Connecting", e.Connected = "Connected", e.Disconnecting = "Disconnecting", e.Reconnecting = "Reconnecting" }(ce || (ce = {})); class ae { static create(e, t, n, o, r, s, i) { return new ae(e, t, n, o, r, s, i) } constructor(e, t, n, o, r, s, i) { this._nextKeepAlive = 0, this._freezeEventListener = () => { this._logger.log(h.Warning, "The page is being frozen, this will likely lead to the connection being closed and messages being lost. For more information see the docs at https://learn.microsoft.com/aspnet/core/signalr/javascript-client#bsleep") }, W.isRequired(e, "connection"), W.isRequired(t, "logger"), W.isRequired(n, "protocol"), this.serverTimeoutInMilliseconds = null != r ? r : 3e4, this.keepAliveIntervalInMilliseconds = null != s ? s : 15e3, this._statefulReconnectBufferSize = null != i ? i : 1e5, this._logger = t, this._protocol = n, this.connection = e, this._reconnectPolicy = o, this._handshakeProtocol = new ne, this.connection.onreceive = e => this._processIncomingData(e), this.connection.onclose = e => this._connectionClosed(e), this._callbacks = {}, this._methods = {}, this._closedCallbacks = [], this._reconnectingCallbacks = [], this._reconnectedCallbacks = [], this._invocationId = 0, this._receivedHandshakeResponse = !1, this._connectionState = ce.Disconnected, this._connectionStarted = !1, this._cachedPingMessage = this._protocol.writeMessage({ type: oe.Ping }) } get state() { return this._connectionState } get connectionId() { return this.connection && this.connection.connectionId || null } get baseUrl() { return this.connection.baseUrl || "" } set baseUrl(e) { if (this._connectionState !== ce.Disconnected && this._connectionState !== ce.Reconnecting) throw new Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url."); if (!e) throw new Error("The HubConnection url must be a valid url."); this.connection.baseUrl = e } start() { return this._startPromise = this._startWithStateTransitions(), this._startPromise } async _startWithStateTransitions() { if (this._connectionState !== ce.Disconnected) return Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state.")); this._connectionState = ce.Connecting, this._logger.log(h.Debug, "Starting HubConnection."); try { await this._startInternal(), L.isBrowser && window.document.addEventListener("freeze", this._freezeEventListener), this._connectionState = ce.Connected, this._connectionStarted = !0, this._logger.log(h.Debug, "HubConnection connected successfully.") } catch (e) { return this._connectionState = ce.Disconnected, this._logger.log(h.Debug, `HubConnection failed to start successfully because of error '${e}'.`), Promise.reject(e) } } async _startInternal() { this._stopDuringStartError = void 0, this._receivedHandshakeResponse = !1; const e = new Promise(((e, t) => { this._handshakeResolver = e, this._handshakeRejecter = t })); await this.connection.start(this._protocol.transferFormat); try { let t = this._protocol.version; this.connection.features.reconnect || (t = 1); const n = { protocol: this._protocol.name, version: t }; if (this._logger.log(h.Debug, "Sending handshake request."), await this._sendMessage(this._handshakeProtocol.writeHandshakeRequest(n)), this._logger.log(h.Information, `Using HubProtocol '${this._protocol.name}'.`), this._cleanupTimeout(), this._resetTimeoutPeriod(), this._resetKeepAliveInterval(), await e, this._stopDuringStartError) throw this._stopDuringStartError; (this.connection.features.reconnect || !1) && (this._messageBuffer = new se(this._protocol, this.connection, this._statefulReconnectBufferSize), this.connection.features.disconnected = this._messageBuffer._disconnected.bind(this._messageBuffer), this.connection.features.resend = () => { if (this._messageBuffer) return this._messageBuffer._resend() }), this.connection.features.inherentKeepAlive || await this._sendMessage(this._cachedPingMessage) } catch (e) { throw this._logger.log(h.Debug, `Hub handshake failed with error '${e}' during start(). Stopping HubConnection.`), this._cleanupTimeout(), this._cleanupPingTimer(), await this.connection.stop(e), e } } async stop() { const e = this._startPromise; this.connection.features.reconnect = !1, this._stopPromise = this._stopInternal(), await this._stopPromise; try { await e } catch (e) { } } _stopInternal(e) { if (this._connectionState === ce.Disconnected) return this._logger.log(h.Debug, `Call to HubConnection.stop(${e}) ignored because it is already in the disconnected state.`), Promise.resolve(); if (this._connectionState === ce.Disconnecting) return this._logger.log(h.Debug, `Call to HttpConnection.stop(${e}) ignored because the connection is already in the disconnecting state.`), this._stopPromise; const t = this._connectionState; return this._connectionState = ce.Disconnecting, this._logger.log(h.Debug, "Stopping HubConnection."), this._reconnectDelayHandle ? (this._logger.log(h.Debug, "Connection stopped during reconnect delay. Done reconnecting."), clearTimeout(this._reconnectDelayHandle), this._reconnectDelayHandle = void 0, this._completeClose(), Promise.resolve()) : (t === ce.Connected && this._sendCloseMessage(), this._cleanupTimeout(), this._cleanupPingTimer(), this._stopDuringStartError = e || new n("The connection was stopped before the hub handshake could complete."), this.connection.stop(e)) } async _sendCloseMessage() { try { await this._sendWithProtocol(this._createCloseMessage()) } catch { } } stream(e, ...t) { const [n, o] = this._replaceStreamingParams(t), r = this._createStreamInvocation(e, t, o); let s; const i = new re; return i.cancelCallback = () => { const e = this._createCancelInvocation(r.invocationId); return delete this._callbacks[r.invocationId], s.then((() => this._sendWithProtocol(e))) }, this._callbacks[r.invocationId] = (e, t) => { t ? i.error(t) : e && (e.type === oe.Completion ? e.error ? i.error(new Error(e.error)) : i.complete() : i.next(e.item)) }, s = this._sendWithProtocol(r).catch((e => { i.error(e), delete this._callbacks[r.invocationId] })), this._launchStreams(n, s), i } _sendMessage(e) { return this._resetKeepAliveInterval(), this.connection.send(e) } _sendWithProtocol(e) { return this._messageBuffer ? this._messageBuffer._send(e) : this._sendMessage(this._protocol.writeMessage(e)) } send(e, ...t) { const [n, o] = this._replaceStreamingParams(t), r = this._sendWithProtocol(this._createInvocation(e, t, !0, o)); return this._launchStreams(n, r), r } invoke(e, ...t) { const [n, o] = this._replaceStreamingParams(t), r = this._createInvocation(e, t, !1, o); return new Promise(((e, t) => { this._callbacks[r.invocationId] = (n, o) => { o ? t(o) : n && (n.type === oe.Completion ? n.error ? t(new Error(n.error)) : e(n.result) : t(new Error(`Unexpected message type: ${n.type}`))) }; const o = this._sendWithProtocol(r).catch((e => { t(e), delete this._callbacks[r.invocationId] })); this._launchStreams(n, o) })) } on(e, t) { e && t && (e = e.toLowerCase(), this._methods[e] || (this._methods[e] = []), -1 === this._methods[e].indexOf(t) && this._methods[e].push(t)) } off(e, t) { if (!e) return; e = e.toLowerCase(); const n = this._methods[e]; if (n) if (t) { const o = n.indexOf(t); -1 !== o && (n.splice(o, 1), 0 === n.length && delete this._methods[e]) } else delete this._methods[e] } onclose(e) { e && this._closedCallbacks.push(e) } onreconnecting(e) { e && this._reconnectingCallbacks.push(e) } onreconnected(e) { e && this._reconnectedCallbacks.push(e) } _processIncomingData(e) { if (this._cleanupTimeout(), this._receivedHandshakeResponse || (e = this._processHandshakeResponse(e), this._receivedHandshakeResponse = !0), e) { const t = this._protocol.parseMessages(e, this._logger); for (const e of t) if (!this._messageBuffer || this._messageBuffer._shouldProcessMessage(e)) switch (e.type) { case oe.Invocation: this._invokeClientMethod(e); break; case oe.StreamItem: case oe.Completion: { const t = this._callbacks[e.invocationId]; if (t) { e.type === oe.Completion && delete this._callbacks[e.invocationId]; try { t(e) } catch (e) { this._logger.log(h.Error, `Stream callback threw error: ${Q(e)}`) } } break } case oe.Ping: break; case oe.Close: { this._logger.log(h.Information, "Close message received from server."); const t = e.error ? new Error("Server returned an error on close: " + e.error) : void 0; !0 === e.allowReconnect ? this.connection.stop(t) : this._stopPromise = this._stopInternal(t); break } case oe.Ack: this._messageBuffer && this._messageBuffer._ack(e); break; case oe.Sequence: this._messageBuffer && this._messageBuffer._resetSequence(e); break; default: this._logger.log(h.Warning, `Invalid message type: ${e.type}.`) } } this._resetTimeoutPeriod() } _processHandshakeResponse(e) { let t, n; try { [n, t] = this._handshakeProtocol.parseHandshakeResponse(e) } catch (e) { const t = "Error parsing handshake response: " + e; this._logger.log(h.Error, t); const n = new Error(t); throw this._handshakeRejecter(n), n } if (t.error) { const e = "Server returned handshake error: " + t.error; this._logger.log(h.Error, e); const n = new Error(e); throw this._handshakeRejecter(n), n } return this._logger.log(h.Debug, "Server handshake complete."), this._handshakeResolver(), n } _resetKeepAliveInterval() { this.connection.features.inherentKeepAlive || (this._nextKeepAlive = (new Date).getTime() + this.keepAliveIntervalInMilliseconds, this._cleanupPingTimer()) } _resetTimeoutPeriod() { if (!(this.connection.features && this.connection.features.inherentKeepAlive || (this._timeoutHandle = setTimeout((() => this.serverTimeout()), this.serverTimeoutInMilliseconds), void 0 !== this._pingServerHandle))) { let e = this._nextKeepAlive - (new Date).getTime(); e < 0 && (e = 0), this._pingServerHandle = setTimeout((async () => { if (this._connectionState === ce.Connected) try { await this._sendMessage(this._cachedPingMessage) } catch { this._cleanupPingTimer() } }), e) } } serverTimeout() { this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server.")) } async _invokeClientMethod(e) { const t = e.target.toLowerCase(), n = this._methods[t]; if (!n) return this._logger.log(h.Warning, `No client method with the name '${t}' found.`), void (e.invocationId && (this._logger.log(h.Warning, `No result given for '${t}' method and invocation ID '${e.invocationId}'.`), await this._sendWithProtocol(this._createCompletionMessage(e.invocationId, "Client didn't provide a result.", null)))); const o = n.slice(), r = !!e.invocationId; let s, i, c; for (const n of o) try { const o = s; s = await n.apply(this, e.arguments), r && s && o && (this._logger.log(h.Error, `Multiple results provided for '${t}'. Sending error to server.`), c = this._createCompletionMessage(e.invocationId, "Client provided multiple results.", null)), i = void 0 } catch (e) { i = e, this._logger.log(h.Error, `A callback for the method '${t}' threw error '${e}'.`) } c ? await this._sendWithProtocol(c) : r ? (i ? c = this._createCompletionMessage(e.invocationId, `${i}`, null) : void 0 !== s ? c = this._createCompletionMessage(e.invocationId, null, s) : (this._logger.log(h.Warning, `No result given for '${t}' method and invocation ID '${e.invocationId}'.`), c = this._createCompletionMessage(e.invocationId, "Client didn't provide a result.", null)), await this._sendWithProtocol(c)) : s && this._logger.log(h.Error, `Result given for '${t}' method but server is not expecting a result.`) } _connectionClosed(e) { this._logger.log(h.Debug, `HubConnection.connectionClosed(${e}) called while in state ${this._connectionState}.`), this._stopDuringStartError = this._stopDuringStartError || e || new n("The underlying connection was closed before the hub handshake could complete."), this._handshakeResolver && this._handshakeResolver(), this._cancelCallbacksWithError(e || new Error("Invocation canceled due to the underlying connection being closed.")), this._cleanupTimeout(), this._cleanupPingTimer(), this._connectionState === ce.Disconnecting ? this._completeClose(e) : this._connectionState === ce.Connected && this._reconnectPolicy ? this._reconnect(e) : this._connectionState === ce.Connected && this._completeClose(e) } _completeClose(e) { if (this._connectionStarted) { this._connectionState = ce.Disconnected, this._connectionStarted = !1, this._messageBuffer && (this._messageBuffer._dispose(null != e ? e : new Error("Connection closed.")), this._messageBuffer = void 0), L.isBrowser && window.document.removeEventListener("freeze", this._freezeEventListener); try { this._closedCallbacks.forEach((t => t.apply(this, [e]))) } catch (t) { this._logger.log(h.Error, `An onclose callback called with error '${e}' threw error '${t}'.`) } } } async _reconnect(e) { const t = Date.now(); let n = 0, o = void 0 !== e ? e : new Error("Attempting to reconnect due to a unknown error."), r = this._getNextRetryDelay(n++, 0, o); if (null === r) return this._logger.log(h.Debug, "Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt."), void this._completeClose(e); if (this._connectionState = ce.Reconnecting, e ? this._logger.log(h.Information, `Connection reconnecting because of error '${e}'.`) : this._logger.log(h.Information, "Connection reconnecting."), 0 !== this._reconnectingCallbacks.length) { try { this._reconnectingCallbacks.forEach((t => t.apply(this, [e]))) } catch (t) { this._logger.log(h.Error, `An onreconnecting callback called with error '${e}' threw error '${t}'.`) } if (this._connectionState !== ce.Reconnecting) return void this._logger.log(h.Debug, "Connection left the reconnecting state in onreconnecting callback. Done reconnecting.") } for (; null !== r;) { if (this._logger.log(h.Information, `Reconnect attempt number ${n} will start in ${r} ms.`), await new Promise((e => { this._reconnectDelayHandle = setTimeout(e, r) })), this._reconnectDelayHandle = void 0, this._connectionState !== ce.Reconnecting) return void this._logger.log(h.Debug, "Connection left the reconnecting state during reconnect delay. Done reconnecting."); try { if (await this._startInternal(), this._connectionState = ce.Connected, this._logger.log(h.Information, "HubConnection reconnected successfully."), 0 !== this._reconnectedCallbacks.length) try { this._reconnectedCallbacks.forEach((e => e.apply(this, [this.connection.connectionId]))) } catch (e) { this._logger.log(h.Error, `An onreconnected callback called with connectionId '${this.connection.connectionId}; threw error '${e}'.`) } return } catch (e) { if (this._logger.log(h.Information, `Reconnect attempt failed because of error '${e}'.`), this._connectionState !== ce.Reconnecting) return this._logger.log(h.Debug, `Connection moved to the '${this._connectionState}' from the reconnecting state during reconnect attempt. Done reconnecting.`), void (this._connectionState === ce.Disconnecting && this._completeClose()); o = e instanceof Error ? e : new Error(e.toString()), r = this._getNextRetryDelay(n++, Date.now() - t, o) } } this._logger.log(h.Information, `Reconnect retries have been exhausted after ${Date.now() - t} ms and ${n} failed attempts. Connection disconnecting.`), this._completeClose() } _getNextRetryDelay(e, t, n) { try { return this._reconnectPolicy.nextRetryDelayInMilliseconds({ elapsedMilliseconds: t, previousRetryCount: e, retryReason: n }) } catch (n) { return this._logger.log(h.Error, `IRetryPolicy.nextRetryDelayInMilliseconds(${e}, ${t}) threw error '${n}'.`), null } } _cancelCallbacksWithError(e) { const t = this._callbacks; this._callbacks = {}, Object.keys(t).forEach((n => { const o = t[n]; try { o(null, e) } catch (t) { this._logger.log(h.Error, `Stream 'error' callback called with '${e}' threw error: ${Q(t)}`) } })) } _cleanupPingTimer() { this._pingServerHandle && (clearTimeout(this._pingServerHandle), this._pingServerHandle = void 0) } _cleanupTimeout() { this._timeoutHandle && clearTimeout(this._timeoutHandle) } _createInvocation(e, t, n, o) { if (n) return 0 !== o.length ? { arguments: t, streamIds: o, target: e, type: oe.Invocation } : { arguments: t, target: e, type: oe.Invocation }; { const n = this._invocationId; return this._invocationId++, 0 !== o.length ? { arguments: t, invocationId: n.toString(), streamIds: o, target: e, type: oe.Invocation } : { arguments: t, invocationId: n.toString(), target: e, type: oe.Invocation } } } _launchStreams(e, t) { if (0 !== e.length) { t || (t = Promise.resolve()); for (const n in e) e[n].subscribe({ complete: () => { t = t.then((() => this._sendWithProtocol(this._createCompletionMessage(n)))) }, error: e => { let o; o = e instanceof Error ? e.message : e && e.toString ? e.toString() : "Unknown error", t = t.then((() => this._sendWithProtocol(this._createCompletionMessage(n, o)))) }, next: e => { t = t.then((() => this._sendWithProtocol(this._createStreamItemMessage(n, e)))) } }) } } _replaceStreamingParams(e) { const t = [], n = []; for (let o = 0; o < e.length; o++) { const r = e[o]; if (this._isObservable(r)) { const s = this._invocationId; this._invocationId++, t[s] = r, n.push(s.toString()), e.splice(o, 1) } } return [t, n] } _isObservable(e) { return e && e.subscribe && "function" == typeof e.subscribe } _createStreamInvocation(e, t, n) { const o = this._invocationId; return this._invocationId++, 0 !== n.length ? { arguments: t, invocationId: o.toString(), streamIds: n, target: e, type: oe.StreamInvocation } : { arguments: t, invocationId: o.toString(), target: e, type: oe.StreamInvocation } } _createCancelInvocation(e) { return { invocationId: e, type: oe.CancelInvocation } } _createStreamItemMessage(e, t) { return { invocationId: e, item: t, type: oe.StreamItem } } _createCompletionMessage(e, t, n) { return t ? { error: t, invocationId: e, type: oe.Completion } : { invocationId: e, result: n, type: oe.Completion } } _createCloseMessage() { return { type: oe.Close } } } const le = [0, 2e3, 1e4, 3e4, null]; class he { constructor(e) { this._retryDelays = void 0 !== e ? [...e, null] : le } nextRetryDelayInMilliseconds(e) { return this._retryDelays[e.previousRetryCount] } } class ue { } ue.Authorization = "Authorization", ue.Cookie = "Cookie"; class ge extends l { constructor(e, t) { super(), this._innerClient = e, this._accessTokenFactory = t } async send(e) { let t = !0; this._accessTokenFactory && (!this._accessToken || e.url && e.url.indexOf("/negotiate?") > 0) && (t = !1, this._accessToken = await this._accessTokenFactory()), this._setAuthorizationHeader(e); const n = await this._innerClient.send(e); return t && 401 === n.statusCode && this._accessTokenFactory ? (this._accessToken = await this._accessTokenFactory(), this._setAuthorizationHeader(e), await this._innerClient.send(e)) : n } _setAuthorizationHeader(e) { e.headers || (e.headers = {}), this._accessToken ? e.headers[ue.Authorization] = `Bearer ${this._accessToken}` : this._accessTokenFactory && e.headers[ue.Authorization] && delete e.headers[ue.Authorization] } getCookieString(e) { return this._innerClient.getCookieString(e) } } var de, _e; !function (e) { e[e.None = 0] = "None", e[e.WebSockets = 1] = "WebSockets", e[e.ServerSentEvents = 2] = "ServerSentEvents", e[e.LongPolling = 4] = "LongPolling" }(de || (de = {})), function (e) { e[e.Text = 1] = "Text", e[e.Binary = 2] = "Binary" }(_e || (_e = {})); class pe { constructor() { this._isAborted = !1, this.onabort = null } abort() { this._isAborted || (this._isAborted = !0, this.onabort && this.onabort()) } get signal() { return this } get aborted() { return this._isAborted } } class fe { get pollAborted() { return this._pollAbort.aborted } constructor(e, t, n) { this._httpClient = e, this._logger = t, this._pollAbort = new pe, this._options = n, this._running = !1, this.onreceive = null, this.onclose = null } async connect(t, n) { if (W.isRequired(t, "url"), W.isRequired(n, "transferFormat"), W.isIn(n, _e, "transferFormat"), this._url = t, this._logger.log(h.Trace, "(LongPolling transport) Connecting."), n === _e.Binary && "undefined" != typeof XMLHttpRequest && "string" != typeof (new XMLHttpRequest).responseType) throw new Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported."); const [o, r] = z(), s = { [o]: r, ...this._options.headers }, i = { abortSignal: this._pollAbort.signal, headers: s, timeout: 1e5, withCredentials: this._options.withCredentials }; n === _e.Binary && (i.responseType = "arraybuffer"); const c = `${t}&_=${Date.now()}`; this._logger.log(h.Trace, `(LongPolling transport) polling: ${c}.`); const a = await this._httpClient.get(c, i); 200 !== a.statusCode ? (this._logger.log(h.Error, `(LongPolling transport) Unexpected response code: ${a.statusCode}.`), this._closeError = new e(a.statusText || "", a.statusCode), this._running = !1) : this._running = !0, this._receiving = this._poll(this._url, i) } async _poll(n, o) { try { for (; this._running;)try { const t = `${n}&_=${Date.now()}`; this._logger.log(h.Trace, `(LongPolling transport) polling: ${t}.`); const r = await this._httpClient.get(t, o); 204 === r.statusCode ? (this._logger.log(h.Information, "(LongPolling transport) Poll terminated by server."), this._running = !1) : 200 !== r.statusCode ? (this._logger.log(h.Error, `(LongPolling transport) Unexpected response code: ${r.statusCode}.`), this._closeError = new e(r.statusText || "", r.statusCode), this._running = !1) : r.content ? (this._logger.log(h.Trace, `(LongPolling transport) data received. ${j(r.content, this._options.logMessageContent)}.`), this.onreceive && this.onreceive(r.content)) : this._logger.log(h.Trace, "(LongPolling transport) Poll timed out, reissuing.") } catch (e) { this._running ? e instanceof t ? this._logger.log(h.Trace, "(LongPolling transport) Poll timed out, reissuing.") : (this._closeError = e, this._running = !1) : this._logger.log(h.Trace, `(LongPolling transport) Poll errored after shutdown: ${e.message}`) } } finally { this._logger.log(h.Trace, "(LongPolling transport) Polling complete."), this.pollAborted || this._raiseOnClose() } } async send(e) { return this._running ? F(this._logger, "LongPolling", this._httpClient, this._url, e, this._options) : Promise.reject(new Error("Cannot send until the transport is connected")) } async stop() { this._logger.log(h.Trace, "(LongPolling transport) Stopping polling."), this._running = !1, this._pollAbort.abort(); try { await this._receiving, this._logger.log(h.Trace, `(LongPolling transport) sending DELETE request to ${this._url}.`); const t = {}, [n, o] = z(); t[n] = o; const r = { headers: { ...t, ...this._options.headers }, timeout: this._options.timeout, withCredentials: this._options.withCredentials }; let s; try { await this._httpClient.delete(this._url, r) } catch (e) { s = e } s ? s instanceof e && (404 === s.statusCode ? this._logger.log(h.Trace, "(LongPolling transport) A 404 response was returned from sending a DELETE request.") : this._logger.log(h.Trace, `(LongPolling transport) Error sending a DELETE request: ${s}`)) : this._logger.log(h.Trace, "(LongPolling transport) DELETE request accepted.") } finally { this._logger.log(h.Trace, "(LongPolling transport) Stop finished."), this._raiseOnClose() } } _raiseOnClose() { if (this.onclose) { let e = "(LongPolling transport) Firing onclose event."; this._closeError && (e += " Error: " + this._closeError), this._logger.log(h.Trace, e), this.onclose(this._closeError) } } } class me { constructor(e, t, n, o) { this._httpClient = e, this._accessToken = t, this._logger = n, this._options = o, this.onreceive = null, this.onclose = null } async connect(e, t) { return W.isRequired(e, "url"), W.isRequired(t, "transferFormat"), W.isIn(t, _e, "transferFormat"), this._logger.log(h.Trace, "(SSE transport) Connecting."), this._url = e, this._accessToken && (e += (e.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(this._accessToken)}`), new Promise(((n, o) => { let r, s = !1; if (t === _e.Text) { if (L.isBrowser || L.isWebWorker) r = new this._options.EventSource(e, { withCredentials: this._options.withCredentials }); else { const t = this._httpClient.getCookieString(e), n = {}; n.Cookie = t; const [o, s] = z(); n[o] = s, r = new this._options.EventSource(e, { withCredentials: this._options.withCredentials, headers: { ...n, ...this._options.headers } }) } try { r.onmessage = e => { if (this.onreceive) try { this._logger.log(h.Trace, `(SSE transport) data received. ${j(e.data, this._options.logMessageContent)}.`), this.onreceive(e.data) } catch (e) { return void this._close(e) } }, r.onerror = e => { s ? this._close() : o(new Error("EventSource failed to connect. The connection could not be found on the server, either the connection ID is not present on the server, or a proxy is refusing/buffering the connection. If you have multiple servers check that sticky sessions are enabled.")) }, r.onopen = () => { this._logger.log(h.Information, `SSE connected to ${this._url}`), this._eventSource = r, s = !0, n() } } catch (e) { return void o(e) } } else o(new Error("The Server-Sent Events transport only supports the 'Text' transfer format")) })) } async send(e) { return this._eventSource ? F(this._logger, "SSE", this._httpClient, this._url, e, this._options) : Promise.reject(new Error("Cannot send until the transport is connected")) } stop() { return this._close(), Promise.resolve() } _close(e) { this._eventSource && (this._eventSource.close(), this._eventSource = void 0, this.onclose && this.onclose(e)) } } class we { constructor(e, t, n, o, r, s) { this._logger = n, this._accessTokenFactory = t, this._logMessageContent = o, this._webSocketConstructor = r, this._httpClient = e, this.onreceive = null, this.onclose = null, this._headers = s } async connect(e, t) { let n; return W.isRequired(e, "url"), W.isRequired(t, "transferFormat"), W.isIn(t, _e, "transferFormat"), this._logger.log(h.Trace, "(WebSockets transport) Connecting."), this._accessTokenFactory && (n = await this._accessTokenFactory()), new Promise(((o, r) => { let s; e = e.replace(/^http/, "ws"); const i = this._httpClient.getCookieString(e); let c = !1; if (L.isNode || L.isReactNative) { const t = {}, [o, r] = z(); t[o] = r, n && (t[ue.Authorization] = `Bearer ${n}`), i && (t[ue.Cookie] = i), s = new this._webSocketConstructor(e, void 0, { headers: { ...t, ...this._headers } }) } else n && (e += (e.indexOf("?") < 0 ? "?" : "&") + `access_token=${encodeURIComponent(n)}`); s || (s = new this._webSocketConstructor(e)), t === _e.Binary && (s.binaryType = "arraybuffer"), s.onopen = t => { this._logger.log(h.Information, `WebSocket connected to ${e}.`), this._webSocket = s, c = !0, o() }, s.onerror = e => { let t = null; t = "undefined" != typeof ErrorEvent && e instanceof ErrorEvent ? e.error : "There was an error with the transport", this._logger.log(h.Information, `(WebSockets transport) ${t}.`) }, s.onmessage = e => { if (this._logger.log(h.Trace, `(WebSockets transport) data received. ${j(e.data, this._logMessageContent)}.`), this.onreceive) try { this.onreceive(e.data) } catch (e) { return void this._close(e) } }, s.onclose = e => { if (c) this._close(e); else { let t = null; t = "undefined" != typeof ErrorEvent && e instanceof ErrorEvent ? e.error : "WebSocket failed to connect. The connection could not be found on the server, either the endpoint may not be a SignalR endpoint, the connection ID is not present on the server, or there is a proxy blocking WebSockets. If you have multiple servers check that sticky sessions are enabled.", r(new Error(t)) } } })) } send(e) { return this._webSocket && this._webSocket.readyState === this._webSocketConstructor.OPEN ? (this._logger.log(h.Trace, `(WebSockets transport) sending data. ${j(e, this._logMessageContent)}.`), this._webSocket.send(e), Promise.resolve()) : Promise.reject("WebSocket is not in the OPEN state") } stop() { return this._webSocket && this._close(void 0), Promise.resolve() } _close(e) { this._webSocket && (this._webSocket.onclose = () => { }, this._webSocket.onmessage = () => { }, this._webSocket.onerror = () => { }, this._webSocket.close(), this._webSocket = void 0), this._logger.log(h.Trace, "(WebSockets transport) socket closed."), this.onclose && (!this._isCloseEvent(e) || !1 !== e.wasClean && 1e3 === e.code ? e instanceof Error ? this.onclose(e) : this.onclose() : this.onclose(new Error(`WebSocket closed with status code: ${e.code} (${e.reason || "no reason given"}).`))) } _isCloseEvent(e) { return e && "boolean" == typeof e.wasClean && "number" == typeof e.code } } class ve { constructor(e, t = {}) { var n; if (this._stopPromiseResolver = () => { }, this.features = {}, this._negotiateVersion = 1, W.isRequired(e, "url"), this._logger = void 0 === (n = t.logger) ? new O(h.Information) : null === n ? N.instance : void 0 !== n.log ? n : new O(n), this.baseUrl = this._resolveUrl(e), (t = t || {}).logMessageContent = void 0 !== t.logMessageContent && t.logMessageContent, "boolean" != typeof t.withCredentials && void 0 !== t.withCredentials) throw new Error("withCredentials option was not a 'boolean' or 'undefined' value"); t.withCredentials = void 0 === t.withCredentials || t.withCredentials, t.timeout = void 0 === t.timeout ? 1e5 : t.timeout; let o = null, r = null; L.isNode && "undefined" != typeof require && (o = require("ws"), r = require("eventsource")), L.isNode || "undefined" == typeof WebSocket || t.WebSocket ? L.isNode && !t.WebSocket && o && (t.WebSocket = o) : t.WebSocket = WebSocket, L.isNode || "undefined" == typeof EventSource || t.EventSource ? L.isNode && !t.EventSource && void 0 !== r && (t.EventSource = r) : t.EventSource = EventSource, this._httpClient = new ge(t.httpClient || new ee(this._logger), t.accessTokenFactory), this._connectionState = "Disconnected", this._connectionStarted = !1, this._options = t, this.onreceive = null, this.onclose = null } async start(e) { if (e = e || _e.Binary, W.isIn(e, _e, "transferFormat"), this._logger.log(h.Debug, `Starting connection with transfer format '${_e[e]}'.`), "Disconnected" !== this._connectionState) return Promise.reject(new Error("Cannot start an HttpConnection that is not in the 'Disconnected' state.")); if (this._connectionState = "Connecting", this._startInternalPromise = this._startInternal(e), await this._startInternalPromise, "Disconnecting" === this._connectionState) { const e = "Failed to start the HttpConnection before stop() was called."; return this._logger.log(h.Error, e), await this._stopPromise, Promise.reject(new n(e)) } if ("Connected" !== this._connectionState) { const e = "HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!"; return this._logger.log(h.Error, e), Promise.reject(new n(e)) } this._connectionStarted = !0 } send(e) { return "Connected" !== this._connectionState ? Promise.reject(new Error("Cannot send data if the connection is not in the 'Connected' State.")) : (this._sendQueue || (this._sendQueue = new be(this.transport)), this._sendQueue.send(e)) } async stop(e) { return "Disconnected" === this._connectionState ? (this._logger.log(h.Debug, `Call to HttpConnection.stop(${e}) ignored because the connection is already in the disconnected state.`), Promise.resolve()) : "Disconnecting" === this._connectionState ? (this._logger.log(h.Debug, `Call to HttpConnection.stop(${e}) ignored because the connection is already in the disconnecting state.`), this._stopPromise) : (this._connectionState = "Disconnecting", this._stopPromise = new Promise((e => { this._stopPromiseResolver = e })), await this._stopInternal(e), void await this._stopPromise) } async _stopInternal(e) { this._stopError = e; try { await this._startInternalPromise } catch (e) { } if (this.transport) { try { await this.transport.stop() } catch (e) { this._logger.log(h.Error, `HttpConnection.transport.stop() threw error '${e}'.`), this._stopConnection() } this.transport = void 0 } else this._logger.log(h.Debug, "HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.") } async _startInternal(e) { let t = this.baseUrl; this._accessTokenFactory = this._options.accessTokenFactory, this._httpClient._accessTokenFactory = this._accessTokenFactory; try { if (this._options.skipNegotiation) { if (this._options.transport !== de.WebSockets) throw new Error("Negotiation can only be skipped when using the WebSocket transport directly."); this.transport = this._constructTransport(de.WebSockets), await this._startTransport(t, e) } else { let o = null, r = 0; do { if (o = await this._getNegotiationResponse(t), "Disconnecting" === this._connectionState || "Disconnected" === this._connectionState) throw new n("The connection was stopped during negotiation."); if (o.error) throw new Error(o.error); if (o.ProtocolVersion) throw new Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details."); if (o.url && (t = o.url), o.accessToken) { const e = o.accessToken; this._accessTokenFactory = () => e, this._httpClient._accessToken = e, this._httpClient._accessTokenFactory = void 0 } r++ } while (o.url && r < 100); if (100 === r && o.url) throw new Error("Negotiate redirection limit exceeded."); await this._createTransport(t, this._options.transport, o, e) } this.transport instanceof fe && (this.features.inherentKeepAlive = !0), "Connecting" === this._connectionState && (this._logger.log(h.Debug, "The HttpConnection connected successfully."), this._connectionState = "Connected") } catch (e) { return this._logger.log(h.Error, "Failed to start the connection: " + e), this._connectionState = "Disconnected", this.transport = void 0, this._stopPromiseResolver(), Promise.reject(e) } } async _getNegotiationResponse(t) { const n = {}, [o, r] = z(); n[o] = r; const s = this._resolveNegotiateUrl(t); this._logger.log(h.Debug, `Sending negotiation request: ${s}.`); try { const e = await this._httpClient.post(s, { content: "", headers: { ...n, ...this._options.headers }, timeout: this._options.timeout, withCredentials: this._options.withCredentials }); if (200 !== e.statusCode) return Promise.reject(new Error(`Unexpected status code returned from negotiate '${e.statusCode}'`)); const t = JSON.parse(e.content); return (!t.negotiateVersion || t.negotiateVersion < 1) && (t.connectionToken = t.connectionId), t.useStatefulReconnect && !0 !== this._options._useStatefulReconnect ? Promise.reject(new i("Client didn't negotiate Stateful Reconnect but the server did.")) : t } catch (t) { let n = "Failed to complete negotiation with the server: " + t; return t instanceof e && 404 === t.statusCode && (n += " Either this is not a SignalR endpoint or there is a proxy blocking the connection."), this._logger.log(h.Error, n), Promise.reject(new i(n)) } } _createConnectUrl(e, t) { return t ? e + (-1 === e.indexOf("?") ? "?" : "&") + `id=${t}` : e } async _createTransport(e, t, o, r) { let i = this._createConnectUrl(e, o.connectionToken); if (this._isITransport(t)) return this._logger.log(h.Debug, "Connection was provided an instance of ITransport, using that directly."), this.transport = t, await this._startTransport(i, r), void (this.connectionId = o.connectionId); const a = [], l = o.availableTransports || []; let u = o; for (const o of l) { const c = this._resolveTransportOrError(o, t, r, !0 === (null == u ? void 0 : u.useStatefulReconnect)); if (c instanceof Error) a.push(`${o.transport} failed:`), a.push(c); else if (this._isITransport(c)) { if (this.transport = c, !u) { try { u = await this._getNegotiationResponse(e) } catch (e) { return Promise.reject(e) } i = this._createConnectUrl(e, u.connectionToken) } try { return await this._startTransport(i, r), void (this.connectionId = u.connectionId) } catch (e) { if (this._logger.log(h.Error, `Failed to start the transport '${o.transport}': ${e}`), u = void 0, a.push(new s(`${o.transport} failed: ${e}`, de[o.transport])), "Connecting" !== this._connectionState) { const e = "Failed to select transport before stop() was called."; return this._logger.log(h.Debug, e), Promise.reject(new n(e)) } } } } return a.length > 0 ? Promise.reject(new c(`Unable to connect to the server with any of the available transports. ${a.join(" ")}`, a)) : Promise.reject(new Error("None of the transports supported by the client are supported by the server.")) } _constructTransport(e) { switch (e) { case de.WebSockets: if (!this._options.WebSocket) throw new Error("'WebSocket' is not supported in your environment."); return new we(this._httpClient, this._accessTokenFactory, this._logger, this._options.logMessageContent, this._options.WebSocket, this._options.headers || {}); case de.ServerSentEvents: if (!this._options.EventSource) throw new Error("'EventSource' is not supported in your environment."); return new me(this._httpClient, this._httpClient._accessToken, this._logger, this._options); case de.LongPolling: return new fe(this._httpClient, this._logger, this._options); default: throw new Error(`Unknown transport: ${e}.`) } } _startTransport(e, t) { return this.transport.onreceive = this.onreceive, this.features.reconnect ? this.transport.onclose = async n => { let o = !1; if (this.features.reconnect) { try { this.features.disconnected(), await this.transport.connect(e, t), await this.features.resend() } catch { o = !0 } o && this._stopConnection(n) } else this._stopConnection(n) } : this.transport.onclose = e => this._stopConnection(e), this.transport.connect(e, t) } _resolveTransportOrError(e, t, n, s) { const i = de[e.transport]; if (null == i) return this._logger.log(h.Debug, `Skipping transport '${e.transport}' because it is not supported by this client.`), new Error(`Skipping transport '${e.transport}' because it is not supported by this client.`); if (!function (e, t) { return !e || 0 != (t & e) }(t, i)) return this._logger.log(h.Debug, `Skipping transport '${de[i]}' because it was disabled by the client.`), new r(`'${de[i]}' is disabled by the client.`, i); if (!(e.transferFormats.map((e => _e[e])).indexOf(n) >= 0)) return this._logger.log(h.Debug, `Skipping transport '${de[i]}' because it does not support the requested transfer format '${_e[n]}'.`), new Error(`'${de[i]}' does not support ${_e[n]}.`); if (i === de.WebSockets && !this._options.WebSocket || i === de.ServerSentEvents && !this._options.EventSource) return this._logger.log(h.Debug, `Skipping transport '${de[i]}' because it is not supported in your environment.'`), new o(`'${de[i]}' is not supported in your environment.`, i); this._logger.log(h.Debug, `Selecting transport '${de[i]}'.`); try { return this.features.reconnect = i === de.WebSockets ? s : void 0, this._constructTransport(i) } catch (e) { return e } } _isITransport(e) { return e && "object" == typeof e && "connect" in e } _stopConnection(e) { if (this._logger.log(h.Debug, `HttpConnection.stopConnection(${e}) called while in state ${this._connectionState}.`), this.transport = void 0, e = this._stopError || e, this._stopError = void 0, "Disconnected" !== this._connectionState) { if ("Connecting" === this._connectionState) throw this._logger.log(h.Warning, `Call to HttpConnection.stopConnection(${e}) was ignored because the connection is still in the connecting state.`), new Error(`HttpConnection.stopConnection(${e}) was called while the connection is still in the connecting state.`); if ("Disconnecting" === this._connectionState && this._stopPromiseResolver(), e ? this._logger.log(h.Error, `Connection disconnected with error '${e}'.`) : this._logger.log(h.Information, "Connection disconnected."), this._sendQueue && (this._sendQueue.stop().catch((e => { this._logger.log(h.Error, `TransportSendQueue.stop() threw error '${e}'.`) })), this._sendQueue = void 0), this.connectionId = void 0, this._connectionState = "Disconnected", this._connectionStarted) { this._connectionStarted = !1; try { this.onclose && this.onclose(e) } catch (t) { this._logger.log(h.Error, `HttpConnection.onclose(${e}) threw error '${t}'.`) } } } else this._logger.log(h.Debug, `Call to HttpConnection.stopConnection(${e}) was ignored because the connection is already in the disconnected state.`) } _resolveUrl(e) { if (0 === e.lastIndexOf("https://", 0) || 0 === e.lastIndexOf("http://", 0)) return e; if (!L.isBrowser) throw new Error(`Cannot resolve '${e}'.`); const t = window.document.createElement("a"); return t.href = e, this._logger.log(h.Information, `Normalizing '${e}' to '${t.href}'.`), t.href } _resolveNegotiateUrl(e) { const t = new URL(e); t.pathname.endsWith("/") ? t.pathname += "negotiate" : t.pathname += "/negotiate"; const n = new URLSearchParams(t.searchParams); return n.has("negotiateVersion") || n.append("negotiateVersion", this._negotiateVersion.toString()), n.has("useStatefulReconnect") ? "true" === n.get("useStatefulReconnect") && (this._options._useStatefulReconnect = !0) : !0 === this._options._useStatefulReconnect && n.append("useStatefulReconnect", "true"), t.search = n.toString(), t.toString() } } class be { constructor(e) { this._transport = e, this._buffer = [], this._executing = !0, this._sendBufferedData = new ye, this._transportResult = new ye, this._sendLoopPromise = this._sendLoop() } send(e) { return this._bufferData(e), this._transportResult || (this._transportResult = new ye), this._transportResult.promise } stop() { return this._executing = !1, this._sendBufferedData.resolve(), this._sendLoopPromise } _bufferData(e) { if (this._buffer.length && typeof this._buffer[0] != typeof e) throw new Error(`Expected data to be of type ${typeof this._buffer} but was of type ${typeof e}`); this._buffer.push(e), this._sendBufferedData.resolve() } async _sendLoop() { for (; ;) { if (await this._sendBufferedData.promise, !this._executing) { this._transportResult && this._transportResult.reject("Connection stopped."); break } this._sendBufferedData = new ye; const e = this._transportResult; this._transportResult = void 0; const t = "string" == typeof this._buffer[0] ? this._buffer.join("") : be._concatBuffers(this._buffer); this._buffer.length = 0; try { await this._transport.send(t), e.resolve() } catch (t) { e.reject(t) } } } static _concatBuffers(e) { const t = e.map((e => e.byteLength)).reduce(((e, t) => e + t)), n = new Uint8Array(t); let o = 0; for (const t of e) n.set(new Uint8Array(t), o), o += t.byteLength; return n.buffer } } class ye { constructor() { this.promise = new Promise(((e, t) => [this._resolver, this._rejecter] = [e, t])) } resolve() { this._resolver() } reject(e) { this._rejecter(e) } } class Se { constructor() { this.name = "json", this.version = 2, this.transferFormat = _e.Text } parseMessages(e, t) { if ("string" != typeof e) throw new Error("Invalid input for JSON hub protocol. Expected a string."); if (!e) return []; null === t && (t = N.instance); const n = te.parse(e), o = []; for (const e of n) { const n = JSON.parse(e); if ("number" != typeof n.type) throw new Error("Invalid payload."); switch (n.type) { case oe.Invocation: this._isInvocationMessage(n); break; case oe.StreamItem: this._isStreamItemMessage(n); break; case oe.Completion: this._isCompletionMessage(n); break; case oe.Ping: case oe.Close: break; case oe.Ack: this._isAckMessage(n); break; case oe.Sequence: this._isSequenceMessage(n); break; default: t.log(h.Information, "Unknown message type '" + n.type + "' ignored."); continue }o.push(n) } return o } writeMessage(e) { return te.write(JSON.stringify(e)) } _isInvocationMessage(e) { this._assertNotEmptyString(e.target, "Invalid payload for Invocation message."), void 0 !== e.invocationId && this._assertNotEmptyString(e.invocationId, "Invalid payload for Invocation message.") } _isStreamItemMessage(e) { if (this._assertNotEmptyString(e.invocationId, "Invalid payload for StreamItem message."), void 0 === e.item) throw new Error("Invalid payload for StreamItem message.") } _isCompletionMessage(e) { if (e.result && e.error) throw new Error("Invalid payload for Completion message."); !e.result && e.error && this._assertNotEmptyString(e.error, "Invalid payload for Completion message."), this._assertNotEmptyString(e.invocationId, "Invalid payload for Completion message.") } _isAckMessage(e) { if ("number" != typeof e.sequenceId) throw new Error("Invalid SequenceId for Ack message.") } _isSequenceMessage(e) { if ("number" != typeof e.sequenceId) throw new Error("Invalid SequenceId for Sequence message.") } _assertNotEmptyString(e, t) { if ("string" != typeof e || "" === e) throw new Error(t) } } const Ce = { trace: h.Trace, debug: h.Debug, info: h.Information, information: h.Information, warn: h.Warning, warning: h.Warning, error: h.Error, critical: h.Critical, none: h.None }; class ke { configureLogging(e) { if (W.isRequired(e, "logging"), void 0 !== e.log) this.logger = e; else if ("string" == typeof e) { const t = function (e) { const t = Ce[e.toLowerCase()]; if (void 0 !== t) return t; throw new Error(`Unknown log level: ${e}`) }(e); this.logger = new O(t) } else this.logger = new O(e); return this } withUrl(e, t) { return W.isRequired(e, "url"), W.isNotEmpty(e, "url"), this.url = e, this.httpConnectionOptions = "object" == typeof t ? { ...this.httpConnectionOptions, ...t } : { ...this.httpConnectionOptions, transport: t }, this } withHubProtocol(e) { return W.isRequired(e, "protocol"), this.protocol = e, this } withAutomaticReconnect(e) { if (this.reconnectPolicy) throw new Error("A reconnectPolicy has already been set."); return e ? Array.isArray(e) ? this.reconnectPolicy = new he(e) : this.reconnectPolicy = e : this.reconnectPolicy = new he, this } withServerTimeout(e) { return W.isRequired(e, "milliseconds"), this._serverTimeoutInMilliseconds = e, this } withKeepAliveInterval(e) { return W.isRequired(e, "milliseconds"), this._keepAliveIntervalInMilliseconds = e, this } withStatefulReconnect(e) { return void 0 === this.httpConnectionOptions && (this.httpConnectionOptions = {}), this.httpConnectionOptions._useStatefulReconnect = !0, this._statefulReconnectBufferSize = null == e ? void 0 : e.bufferSize, this } build() { const e = this.httpConnectionOptions || {}; if (void 0 === e.logger && (e.logger = this.logger), !this.url) throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection."); const t = new ve(this.url, e); return ae.create(t, this.logger || N.instance, this.protocol || new Se, this.reconnectPolicy, this._serverTimeoutInMilliseconds, this._keepAliveIntervalInMilliseconds, this._statefulReconnectBufferSize) } } export { n as AbortError, ee as DefaultHttpClient, l as HttpClient, e as HttpError, a as HttpResponse, de as HttpTransportType, ae as HubConnection, ke as HubConnectionBuilder, ce as HubConnectionState, Se as JsonHubProtocol, h as LogLevel, oe as MessageType, N as NullLogger, re as Subject, t as TimeoutError, _e as TransferFormat, A as VERSION }; export default null;
//# sourceMappingURL=/sm/c3b78eeaaa09d1b001d895a7ec02eab881e90c2c208cc9400be44c403ac351c2.map